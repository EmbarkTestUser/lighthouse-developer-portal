{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"example docs \u00b6 This is a basic example of documentation.","title":"Home"},{"location":"#example-docs","text":"This is a basic example of documentation.","title":"example docs"},{"location":"backstage-update/","text":"Automated Backstage Update \u00b6 Backstage Update Workflow file Update Backstage Workflow Jobs \u00b6 check-for-existing-update \u00b6 Description: Before upgrade process begins, this job checks if there is currently an open pull request to update backstage. 1 2 3 4 5 6 7 Steps: - Checkout - Uses: [actions/checkout@v2](https://github.com/actions/checkout) - Checkout github repository so workflow can access it - Check for existing auto-update PR - Uses command line to make cURL request to GitHub API for all open pull requests using the \"auto-update-backstage\" branch - Stores url to open pull request as output link-pr \u00b6 Description: If there is an open pull request to update backstage, this job will output a link to the open pull request. 1 2 3 4 Steps: - Failed to Update Backstage - Uses: [actions/github-script@v3](https://github.com/actions/github-script) - Outputs the open pull request url retrieved from GitHub API request update-backstage \u00b6 Description: If there is no open pull request to update backstage, this job will create a branch, perform the upgrade process, and create a pull request with the new changes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Steps: - Checkout - Uses: [actions/checkout@v2](https://github.com/actions/checkout) - Checkout github repository so workflow can access it - Install Dependencies - Uses yarn install to install dependencies for backstage upgrade process - Update Backstage - Runs npm script \"backstage-update\" which runs \"yarn backstage-cli versions:bump 2>&1 | tee backstage-update-log.txt\" - Compare Create App versions - Uses command line to get current version of \"@backstage/create-app\" from package.json and most recent version from NPM registry - Format PR body - Uses command line to format a summary of the update log to the pull request body - Set output variables - Sets variables for PR title and current date - Create Pull Request - Uses: [peter-evans/create-pull-request@v3](https://github.com/peter-evans/create-pull-request) - Creates pull request containing the changes from running \"backstage-update\" - Pull request body also contains a summary of the update log, outputs from the error log, current and most recent versions of \"@backstage/create-app\" and a link to the create-app changelog - Check outputs - Logs the number and url of the newly generated Pull Request","title":"Backstage Update"},{"location":"backstage-update/#automated-backstage-update","text":"Backstage Update Workflow file","title":"Automated Backstage Update"},{"location":"backstage-update/#update-backstage-workflow-jobs","text":"","title":"Update Backstage Workflow Jobs"},{"location":"backstage-update/#check-for-existing-update","text":"Description: Before upgrade process begins, this job checks if there is currently an open pull request to update backstage. 1 2 3 4 5 6 7 Steps: - Checkout - Uses: [actions/checkout@v2](https://github.com/actions/checkout) - Checkout github repository so workflow can access it - Check for existing auto-update PR - Uses command line to make cURL request to GitHub API for all open pull requests using the \"auto-update-backstage\" branch - Stores url to open pull request as output","title":"check-for-existing-update"},{"location":"backstage-update/#link-pr","text":"Description: If there is an open pull request to update backstage, this job will output a link to the open pull request. 1 2 3 4 Steps: - Failed to Update Backstage - Uses: [actions/github-script@v3](https://github.com/actions/github-script) - Outputs the open pull request url retrieved from GitHub API request","title":"link-pr"},{"location":"backstage-update/#update-backstage","text":"Description: If there is no open pull request to update backstage, this job will create a branch, perform the upgrade process, and create a pull request with the new changes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Steps: - Checkout - Uses: [actions/checkout@v2](https://github.com/actions/checkout) - Checkout github repository so workflow can access it - Install Dependencies - Uses yarn install to install dependencies for backstage upgrade process - Update Backstage - Runs npm script \"backstage-update\" which runs \"yarn backstage-cli versions:bump 2>&1 | tee backstage-update-log.txt\" - Compare Create App versions - Uses command line to get current version of \"@backstage/create-app\" from package.json and most recent version from NPM registry - Format PR body - Uses command line to format a summary of the update log to the pull request body - Set output variables - Sets variables for PR title and current date - Create Pull Request - Uses: [peter-evans/create-pull-request@v3](https://github.com/peter-evans/create-pull-request) - Creates pull request containing the changes from running \"backstage-update\" - Pull request body also contains a summary of the update log, outputs from the error log, current and most recent versions of \"@backstage/create-app\" and a link to the create-app changelog - Check outputs - Logs the number and url of the newly generated Pull Request","title":"update-backstage"},{"location":"deployment/","text":"Automated workflows and infrastructure (WIP) \u00b6 This is a draft and does not represent current state. Application deployment \u00b6 TechDocs publication \u00b6 Jenkins environment variables \u00b6 Name Description TECHDOCS_S3_BUCKET_NAME AWS_ACCESS_KEY_ID AWS IAM user AWS_SECRET_ACCESS_KEY AWS_REGION Minimum IAM user access policy \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"VisualEditor0\", \"Effect\": \"Allow\", \"Action\": [ \"s3:PutObject\", ], \"Resource\": [ \"arn:aws:s3:::TECHDOCS_S3_BUCKET_NAME/*\", \"arn:aws:s3:::TECHDOCS_S3_BUCKET_NAME\" ] } ] } Backstage backend components \u00b6 Backstage backend container environment variables \u00b6 Name Description Privileges, permissions GITHUB_TOKEN GitHub Personal Access Token admin:org:read:org, user:read:user AUTH_GITHUB_CLIENT_ID GitHub OAuth AUTH_GITHUB_CLIENT_SECRET TECHDOCS_S3_BUCKET_NAME AWS_ACCESS_KEY_ID AWS IAM user AWS_SECRET_ACCESS_KEY AWS_REGION POSTGRES_USER PostgreSQL instance user SELECT, INSERT, UPDATE, DELETE, TRUNCATE, CREATE, CONNECT POSTGRES_HOST POSTGRES_PORT POSTGRES_PASSWORD Minimum IAM user policy \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"VisualEditor0\", \"Effect\": \"Allow\", \"Action\": [ \"s3:GetObject\", \"s3:ListBucket\" ], \"Resource\": [ \"arn:aws:s3:::TECHDOCS_S3_BUCKET_NAME/*\", \"arn:aws:s3:::TECHDOCS_S3_BUCKET_NAME\" ] } ] } Backstage frontend components \u00b6","title":"Deployment"},{"location":"deployment/#automated-workflows-and-infrastructure-wip","text":"This is a draft and does not represent current state.","title":"Automated workflows and infrastructure (WIP)"},{"location":"deployment/#application-deployment","text":"","title":"Application deployment"},{"location":"deployment/#techdocs-publication","text":"","title":"TechDocs publication"},{"location":"deployment/#jenkins-environment-variables","text":"Name Description TECHDOCS_S3_BUCKET_NAME AWS_ACCESS_KEY_ID AWS IAM user AWS_SECRET_ACCESS_KEY AWS_REGION","title":"Jenkins environment variables"},{"location":"deployment/#minimum-iam-user-access-policy","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"VisualEditor0\", \"Effect\": \"Allow\", \"Action\": [ \"s3:PutObject\", ], \"Resource\": [ \"arn:aws:s3:::TECHDOCS_S3_BUCKET_NAME/*\", \"arn:aws:s3:::TECHDOCS_S3_BUCKET_NAME\" ] } ] }","title":"Minimum IAM user access policy"},{"location":"deployment/#backstage-backend-components","text":"","title":"Backstage backend components"},{"location":"deployment/#backstage-backend-container-environment-variables","text":"Name Description Privileges, permissions GITHUB_TOKEN GitHub Personal Access Token admin:org:read:org, user:read:user AUTH_GITHUB_CLIENT_ID GitHub OAuth AUTH_GITHUB_CLIENT_SECRET TECHDOCS_S3_BUCKET_NAME AWS_ACCESS_KEY_ID AWS IAM user AWS_SECRET_ACCESS_KEY AWS_REGION POSTGRES_USER PostgreSQL instance user SELECT, INSERT, UPDATE, DELETE, TRUNCATE, CREATE, CONNECT POSTGRES_HOST POSTGRES_PORT POSTGRES_PASSWORD","title":"Backstage backend container environment variables"},{"location":"deployment/#minimum-iam-user-policy","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"VisualEditor0\", \"Effect\": \"Allow\", \"Action\": [ \"s3:GetObject\", \"s3:ListBucket\" ], \"Resource\": [ \"arn:aws:s3:::TECHDOCS_S3_BUCKET_NAME/*\", \"arn:aws:s3:::TECHDOCS_S3_BUCKET_NAME\" ] } ] }","title":"Minimum IAM user policy"},{"location":"deployment/#backstage-frontend-components","text":"","title":"Backstage frontend components"},{"location":"rfc-doc-generator/","text":"[RFC] Documentation Generator \u00b6 Summary : Allow documentation to be generated from code comments. Most documentation generators have a fairly similar syntax. So the main purpose of this RFC is to help decide between which syntax we would like more. I was able to find two generators that I think we should choose between, JSDoc and TypeDoc. Both of these generators have eslint-plugins that would allow us to require comments, and other nitpicking. They also allow us to generate documentation within GitHub Actions which is great. Like I said, the main difference is how the syntax will work with TypeScript. Note: Please feel free to let me know if there is another doc generator that you think we should consider. Background \u00b6 Why do we need a documentation generator? I think I speak for everyone when I say that documenting everything can become a huge pain and can take up time a lot of our time. A documentation generator can take our commented code and build a good looking HTML website, so long as we make good explanatory comments. Automating documentation is just another thing that can save us a ton of time and allow us to work on more important/fun features. Goal \u00b6 To decide on which documentation generator, JSDoc or TypeDoc, should be used when adding comments to the codebase. Similar to the summary both generators have similar syntax, eslint support, and GitHub Actions. The only real decision to make is which syntax we'd rather use. JSDoc \u00b6 JSDoc GitHub JSDoc + TypeScript Playground JSDoc has a lot of support and is quite popular. Documenting code can be incredibly easy and provide a lot of information about what's going on in a file. It's been a great way to add typing to JavaScript without using TypeScript. Supported Types: @type @param (or @arg or @argument) @returns (or @return) @typedef @callback @template @class (or @constructor) @this @extends (or @augments) @enum @deprecated In JSDoc types are listed within the comment. 1 2 3 4 5 6 7 8 9 10 11 12 13 /** @type {string} */ let s ; /** * @param {string} p1 - A string param. * @param {string=} p2 - An optional param (Closure syntax) * @param {string} [p3] - Another optional param (JSDoc syntax). * @param {string} [p4=\"test\"] - An optional param with a default value * @return {string} This is the result */ function stringsStringStrings ( p1 , p2 , p3 , p4 ) { // TODO } Unfortunately, JSDoc doesn't support TypeScript out of the box. There are some plugins like better-docs that can parse .ts | .tsx files. However, types aren't displayed correctly within the generated documentation. Meaning that we'd have to list out types within the comments and within the code. There is a way around it (I've done it before) but it requires some extra time and monkey-patching to get it to work correctly. TypeDoc \u00b6 TypeDoc GitHub It appears that TypeDoc can do everything that JSDoc can, but with out of the box support for TypeScript files. It also uses the tsconfig file to figure out where it should look for .ts | .tsx files. All comments are parsed as Markdown which adds additional styling for us! TypeDoc doesn't support all the tags that JSDoc does, but that's because it infers more information from the TypeScript code. So you are more than welcome to type regular TypeScript without needing to declare types within comments. 1 2 3 4 /** * @param text Comment for parameter \u00b4text\u00b4. */ function doSomething ( target : any , text : string ) : number ; Supported Tags: @param <param name> @typeParam <param name> or @template <param name> @return(s) @event @hidden and @ignore @internal @category @module @typedef, @callback @public, @protected, and @private TypeDoc can also support .js | .jsx files if the allowJS option is set to true in the tsconfig . Just note that it can't derive the type from the code so they would need to be explicitly stated within the comment. Recommendation \u00b6 Considering everything that we would want for a documentation generator. Linting Syntax Highlighting Doc Generation with CI/CD JavaScript/TypeScript Support Tags I believe that TypeDoc is the best choice considering it supports TypeScript out of the box. The syntax isn't very different from JSDoc, we just omit the types after the @param and @returns because it's written within the code!","title":"RFC Doc Generator"},{"location":"rfc-doc-generator/#rfc-documentation-generator","text":"Summary : Allow documentation to be generated from code comments. Most documentation generators have a fairly similar syntax. So the main purpose of this RFC is to help decide between which syntax we would like more. I was able to find two generators that I think we should choose between, JSDoc and TypeDoc. Both of these generators have eslint-plugins that would allow us to require comments, and other nitpicking. They also allow us to generate documentation within GitHub Actions which is great. Like I said, the main difference is how the syntax will work with TypeScript. Note: Please feel free to let me know if there is another doc generator that you think we should consider.","title":"[RFC] Documentation Generator"},{"location":"rfc-doc-generator/#background","text":"Why do we need a documentation generator? I think I speak for everyone when I say that documenting everything can become a huge pain and can take up time a lot of our time. A documentation generator can take our commented code and build a good looking HTML website, so long as we make good explanatory comments. Automating documentation is just another thing that can save us a ton of time and allow us to work on more important/fun features.","title":"Background"},{"location":"rfc-doc-generator/#goal","text":"To decide on which documentation generator, JSDoc or TypeDoc, should be used when adding comments to the codebase. Similar to the summary both generators have similar syntax, eslint support, and GitHub Actions. The only real decision to make is which syntax we'd rather use.","title":"Goal"},{"location":"rfc-doc-generator/#jsdoc","text":"JSDoc GitHub JSDoc + TypeScript Playground JSDoc has a lot of support and is quite popular. Documenting code can be incredibly easy and provide a lot of information about what's going on in a file. It's been a great way to add typing to JavaScript without using TypeScript. Supported Types: @type @param (or @arg or @argument) @returns (or @return) @typedef @callback @template @class (or @constructor) @this @extends (or @augments) @enum @deprecated In JSDoc types are listed within the comment. 1 2 3 4 5 6 7 8 9 10 11 12 13 /** @type {string} */ let s ; /** * @param {string} p1 - A string param. * @param {string=} p2 - An optional param (Closure syntax) * @param {string} [p3] - Another optional param (JSDoc syntax). * @param {string} [p4=\"test\"] - An optional param with a default value * @return {string} This is the result */ function stringsStringStrings ( p1 , p2 , p3 , p4 ) { // TODO } Unfortunately, JSDoc doesn't support TypeScript out of the box. There are some plugins like better-docs that can parse .ts | .tsx files. However, types aren't displayed correctly within the generated documentation. Meaning that we'd have to list out types within the comments and within the code. There is a way around it (I've done it before) but it requires some extra time and monkey-patching to get it to work correctly.","title":"JSDoc"},{"location":"rfc-doc-generator/#typedoc","text":"TypeDoc GitHub It appears that TypeDoc can do everything that JSDoc can, but with out of the box support for TypeScript files. It also uses the tsconfig file to figure out where it should look for .ts | .tsx files. All comments are parsed as Markdown which adds additional styling for us! TypeDoc doesn't support all the tags that JSDoc does, but that's because it infers more information from the TypeScript code. So you are more than welcome to type regular TypeScript without needing to declare types within comments. 1 2 3 4 /** * @param text Comment for parameter \u00b4text\u00b4. */ function doSomething ( target : any , text : string ) : number ; Supported Tags: @param <param name> @typeParam <param name> or @template <param name> @return(s) @event @hidden and @ignore @internal @category @module @typedef, @callback @public, @protected, and @private TypeDoc can also support .js | .jsx files if the allowJS option is set to true in the tsconfig . Just note that it can't derive the type from the code so they would need to be explicitly stated within the comment.","title":"TypeDoc"},{"location":"rfc-doc-generator/#recommendation","text":"Considering everything that we would want for a documentation generator. Linting Syntax Highlighting Doc Generation with CI/CD JavaScript/TypeScript Support Tags I believe that TypeDoc is the best choice considering it supports TypeScript out of the box. The syntax isn't very different from JSDoc, we just omit the types after the @param and @returns because it's written within the code!","title":"Recommendation"},{"location":"running-locally/","text":"Open a Codespace (preferred- work in progress) \u00b6 This repo is configured to run a production-like environment in a GitHub Codespace . Open a Codespace Run application: 1 yarn dev Install and run locally with Docker (work in progress) \u00b6 Prerequisites Install git Install Docker Desktop: Mac , Windows Run 1 sh local.sh start After the application runs for the first time, copy node_modules . While the application is running, run this is a separate terminal: 1 sh local.sh copy Caveats - What does this do : This will install the application and its dependencies and then run the backend and frontend in the same container. To ensure fast hot-reloading, node_modules and postgreSQL db are stored in a docker volume and your local source files are mounted into the container. - Why do you need to copy after the first run : The application uses node_modules from Docker volume not your local files. Copy these locally so that dependencies resolve correctly in your editor. Install and run locally (TBD) \u00b6 Use nvm to install node You will need to update the Backstage configuration for running locally. Update these instructions if you try this out. app-config.yaml is used for Codespaces and it is merged with app-config.production.yaml in production environments. Supporting Codespaces is the priorty so consider that when changing the way configurations are organized.","title":"Running Locally"},{"location":"running-locally/#open-a-codespace-preferred-work-in-progress","text":"This repo is configured to run a production-like environment in a GitHub Codespace . Open a Codespace Run application: 1 yarn dev","title":"Open a Codespace (preferred- work in progress)"},{"location":"running-locally/#install-and-run-locally-with-docker-work-in-progress","text":"Prerequisites Install git Install Docker Desktop: Mac , Windows Run 1 sh local.sh start After the application runs for the first time, copy node_modules . While the application is running, run this is a separate terminal: 1 sh local.sh copy Caveats - What does this do : This will install the application and its dependencies and then run the backend and frontend in the same container. To ensure fast hot-reloading, node_modules and postgreSQL db are stored in a docker volume and your local source files are mounted into the container. - Why do you need to copy after the first run : The application uses node_modules from Docker volume not your local files. Copy these locally so that dependencies resolve correctly in your editor.","title":"Install and run locally with Docker (work in progress)"},{"location":"running-locally/#install-and-run-locally-tbd","text":"Use nvm to install node You will need to update the Backstage configuration for running locally. Update these instructions if you try this out. app-config.yaml is used for Codespaces and it is merged with app-config.production.yaml in production environments. Supporting Codespaces is the priorty so consider that when changing the way configurations are organized.","title":"Install and run locally (TBD)"}]}